# Step 1, import likelihood function
# Step 2, get data at new timestep
# Step 3, calculate likelihood for the data
# Step 4, shift the temporal weight vector by 1
# Step 5, update all the weights

import numpy as np
import matplotlib.pyplot as plt

class DataThings(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y


def rolder(timeseries, time, window):
    length=len(timeseries)
    timeseries=(timeseries[1:length] - timeseries[0:-1] )/ (time[1]-time[0])
    length = np.size(timeseries)  # length of the time series
    A = np.ones((length, length - window + 1))  # create a matrix of ones
    B = np.triu(A, 1)
    C = np.tril(A, -window)
    Proj = A - B - C  # this matrix selects the sections to fourier transform
    M = np.kron(np.reshape(timeseries, [np.size(timeseries), 1]), np.ones(length - window + 1))
    M = np.reshape(M.ravel()[np.flatnonzero(Proj)], (window, length - window + 1))
    der=np.mean(M,1)

    print(der.shape, time[0:length-window+1].shape)
    return DataThings(time[0:length-window+1], der)


def main():

    n = 1000  # number of time steps

    randomvar = np.random.randint(1, n, 1)  # just your friendly random integer between 1 and a n
    t = np.linspace(0, 1, n)
    timeseries = np.concatenate((2 * t[0:randomvar], t[randomvar:n] * 60 - (t[randomvar] * 60 - t[randomvar] * 2)), 0)
    timeseries = timeseries + (np.mean(timeseries) / (50 * np.random.rand(1) + 5)) * 0.001 * np.random.randn(len(t))
    print(len(t), len(timeseries))
    der=rolder(timeseries, t, 300)
    plt.plot(der.y)
    plt.show()

main()